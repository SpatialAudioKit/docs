{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This page describes the process of adding support to SpatialAudioKit for a new audio format not natively supported on Apple platforms, i.e. not supported by "},{"type":"strong","inlineContent":[{"type":"text","text":"AVFoundation"}]},{"type":"text","text":". This is intended for SAK developers not users."}]},{"anchor":"Component-hierarchy-and-interactions","level":2,"type":"heading","text":"Component hierarchy and interactions"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The diagram below illustrates the key components involved in playback of non-native audio files."},{"type":"text","text":" "}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"NewFormatSupport.svg"}]},{"anchor":"BufferPlayer","level":3,"type":"heading","text":"BufferPlayer"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"strong","inlineContent":[{"type":"text","text":"BufferPlayer"}]},{"type":"text","text":" class is a generic file player that is able to perform playback of non-native audio files that can be decoded into PCM buffers."}]},{"anchor":"BufferScheduler","level":3,"type":"heading","text":"BufferScheduler"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"strong","inlineContent":[{"type":"text","text":"BufferScheduler"}]},{"type":"text","text":" class takes care of all the low-level details of PCM buffer scheduling, and signals file playback completion when the last scheduled buffer has finished playing."}]},{"anchor":"FileDecoderProtocol","level":3,"type":"heading","text":"FileDecoderProtocol"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"strong","inlineContent":[{"type":"text","text":"FileDecoderProtocol"}]},{"type":"text","text":" protocol defines a contract that all file renderers for non-native formats should implement. It defines a few basic functions \/ properties:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Decoding a given number of samples."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Seeking to a certain position within the file."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Determining whether or not EOF has been reached."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Determining whether or not sample conversion is required (depending on the format of samples produced by the 3rd party library)."}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Any new file renderer will implement this protocol and encapsulate function calls to the 3rd party library that is used to produce PCM samples. For example, FLACDecoder will encapsulate calls to libflac for FLAC files."}]},{"anchor":"SampleConverter","level":3,"type":"heading","text":"SampleConverter"},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"SampleConverter"}]},{"type":"text","text":" is a wrapper around "},{"type":"strong","inlineContent":[{"type":"text","text":"AVAudioConverter"}]},{"type":"text","text":" that converts PCM samples in an "},{"type":"strong","inlineContent":[{"type":"text","text":"AVAudioPCMBuffer"}]},{"type":"text","text":" to the canonical audio format required by "},{"type":"strong","inlineContent":[{"type":"text","text":"AVFoundation"}]},{"type":"text","text":"."}]},{"anchor":"Steps-to-provide-support-for-a-new-format","level":2,"type":"heading","text":"Steps to provide support for a new format"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In addition to the obvious steps of integrating the relevant 3rd party library and writing wrapper classes and utils, perform the following steps:"}]},{"anchor":"1-Write-an-XYZPlayer-class-that-extends-BufferPlayer<D>","level":3,"type":"heading","text":"1. Write an XYZPlayer class that extends BufferPlayer<D>."},{"type":"paragraph","inlineContent":[{"type":"text","text":"This step is not absolutely necessary, but should be done if the behavior of "},{"type":"strong","inlineContent":[{"type":"text","text":"BufferPlayer"}]},{"type":"text","text":" needs to be customized in any way. For instance, when seeking, "},{"type":"strong","inlineContent":[{"type":"text","text":"OpusPlayer"}]},{"type":"text","text":" first validates that the Opus file supports seeking, so it overrides "},{"type":"strong","inlineContent":[{"type":"text","text":"BufferPlayer.seek()"}]},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Also, you must write a "},{"type":"strong","inlineContent":[{"type":"text","text":"BufferPlayer"}]},{"type":"text","text":" subclass if you wish to override the "},{"type":"strong","inlineContent":[{"type":"text","text":"sampleCountForImmediatePlayback"}]},{"type":"text","text":" and "},{"type":"strong","inlineContent":[{"type":"text","text":"sampleCountForDeferredPlayback"}]},{"type":"text","text":" properties to determine how many samples are scheduled for playback at a time."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"NOTE - The generic type D represents the type of the associated renderer class you will write to perform decoding for the new format (see step #2)."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If no custom behavior is required, this step can be skipped completely."}]},{"anchor":"2-Write-an-XYZDecoder-class-that-implements-FileDecoderProtocol","level":3,"type":"heading","text":"2. Write an XYZDecoder class that implements FileDecoderProtocol."},{"type":"paragraph","inlineContent":[{"type":"text","text":"This step is absolutely necessary. This is where the actual decoding occurs, through calls to the 3rd party library responsible for actual decoding."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"See the "},{"type":"strong","inlineContent":[{"type":"text","text":"FileDecoderProtocol"}]},{"type":"text","text":" protocol for details on what needs to be implemented, and see "},{"type":"strong","inlineContent":[{"type":"text","text":"OpusDecoder"}]},{"type":"text","text":" for an example implementation."}]},{"anchor":"3-Add-a-new-initializer-to-SAKFileInfo","level":3,"type":"heading","text":"3. Add a new initializer to SAKFileInfo"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This step is absolutely necessary."}]},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"SAKFileInfo"}]},{"type":"text","text":" stores information that SAK uses for playback and to provide metadata to clients. You must add a new initializer to "},{"type":"strong","inlineContent":[{"type":"text","text":"SAKFileInfo"}]},{"type":"text","text":" that will read the given file and set its playback \/ metadata properties."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For an example of how this is already done for the Opus format, see "},{"type":"strong","inlineContent":[{"type":"text","text":"SAKFileInfo.init(opusFile: OpusFile)"}]},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This new initializer may accept an argument of a type that may be a new file wrapper class that is written for the new format (analogous to "},{"type":"strong","inlineContent":[{"type":"text","text":"OpusFile"}]},{"type":"text","text":" for Opus). For instance, if the new format is FLAC, a new wrapper class called "},{"type":"strong","inlineContent":[{"type":"text","text":"FLACFile"}]},{"type":"text","text":" may be written, and this will then be the type of the argument passed to the new initializer."}]},{"anchor":"4-Add-a-new-else-clause-to-SAKPlayer+Playback","level":3,"type":"heading","text":"4. Add a new else clause to SAKPlayer+Playback"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This step is absolutely necessary."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In "},{"type":"strong","inlineContent":[{"type":"text","text":"SAKPlayer+Playback.swift"}]},{"type":"text","text":", there is a helper function:"}]},{"type":"codeListing","syntax":"swift","code":["func createFilePlayer(for file: URL)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Inside this function, add a new "},{"type":"strong","inlineContent":[{"type":"text","text":"else if"}]},{"type":"text","text":" clause to create a new instance of your new file player class (step 1) or "},{"type":"strong","inlineContent":[{"type":"text","text":"BufferPlayer"}]},{"type":"text","text":" depending on whether you have a custom player class or are using "},{"type":"strong","inlineContent":[{"type":"text","text":"BufferPlayer"}]},{"type":"text","text":" itself."}]},{"anchor":"If-you-have-a-new-file-player-for-FLAC","level":4,"type":"heading","text":"If you have a new file player for FLAC"},{"type":"codeListing","syntax":"swift","code":["else if file.isFLACFile {","    return FLACPlayer(forFile: fileInfo, audioGraph: audioGraph, playbackContext: playbackContext)","}"]},{"anchor":"If-you-are-using-BufferPlayer-no-new-custom-player-class","level":4,"type":"heading","text":"If you are using BufferPlayer (no new custom player class)"},{"type":"codeListing","syntax":"swift","code":["else if file.isFLACFile {","    return BufferPlayer<FLACDecoder>(forFile: fileInfo, audioGraph: audioGraph, playbackContext: playbackContext)","}"]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/spatialaudiokit\/addingsupport"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/SpatialAudioKit\/documentation\/SpatialAudioKit\/AddingSupport","interfaceLanguage":"swift"},"kind":"article","metadata":{"roleHeading":"Article","title":"Adding support for a new audio file format","role":"article","modules":[{"name":"SpatialAudioKit"}]},"hierarchy":{"paths":[["doc:\/\/SpatialAudioKit\/documentation\/SpatialAudioKit"]]},"references":{"doc://SpatialAudioKit/documentation/SpatialAudioKit":{"role":"collection","title":"SpatialAudioKit","abstract":[{"type":"image","identifier":"SAKIcon.png"}],"identifier":"doc:\/\/SpatialAudioKit\/documentation\/SpatialAudioKit","kind":"symbol","type":"topic","url":"\/documentation\/spatialaudiokit"},"NewFormatSupport.svg":{"alt":"Component hierarchy and interactions diagram","type":"image","identifier":"NewFormatSupport.svg","variants":[{"url":"\/images\/NewFormatSupport.svg","traits":["1x","light"]}]}}}